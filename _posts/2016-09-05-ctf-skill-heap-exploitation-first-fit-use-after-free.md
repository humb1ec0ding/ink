---
layout: post
title: "[CTF skill] heap exploitation : first fit use after fit"
date: 2016-09-05 11:20:00
categories: ctf
tags:  [heap]
---

CTF pwnable 문제에서 항상 나오는 유형이 menu 왔다 갔다 하면서 exploit 하는 문제가 많은데, bof 만 겨우 아는 나로서는 대부분 이런 문제는 어떻게 푸는지 잘 몰랐다.  그런데, 이런 경우 heap alloc/free 하는 과정에서  **heap exploitation** 하는 문제가 많다고 해서 heap 공격에 대해서 하나씩 공부해보자.

<!--more--> 

[shellphish/how2heap: A repository for learning various heap exploitation techniques.](https://github.com/shellphish/how2heap)

이중에서 glibc allocator 특성인 first fit 에 대한 코드를 살펴보자.

```
This file doesn't demonstrate an attack, but shows the nature of glibc's allocator.
glibc uses a first-fit algorithm to select a free chunk.
If a chunk is free and large enough, malloc will select this chunk.
This can be exploited in a use-after-free situation.
```

## Code

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main()
{
	printf("This file doesn't demonstrate an attack, but shows the nature of glibc's allocator.\n");
	printf("glibc uses a first-fit algorithm to select a free chunk.\n");
	printf("If a chunk is free and large enough, malloc will select this chunk.\n");
	printf("This can be exploited in a use-after-free situation.\n");

	printf("Allocating 2 buffers. They can be large, don't have to be fastbin.\n");
	char* a = malloc(512);
	char* b = malloc(256);
	char* c;

	printf("1st malloc(512): %p\n", a);
	printf("2nd malloc(256): %p\n", b);
	printf("we could continue mallocing here...\n");
	printf("now let's put a string at a that we can read later \"this is A!\"\n");
	strcpy(a, "this is A!");
	printf("first allocation %p points to %s\n", a, a);

	printf("Freeing the first one...\n");
	free(a);

	printf("We don't need to free anything again. As long as we allocate less than 512, it will end up at %p\n", a);

	printf("So, let's allocate 500 bytes\n");
	c = malloc(500);
	printf("3rd malloc(500): %p\n", c);
	printf("And put a different string here, \"this is C!\"\n");
	strcpy(c, "this is C!");
	printf("3rd allocation %p points to %s\n", c, c);
	printf("first allocation %p points to %s\n", a, a);
	printf("If we reuse the first allocation, it now holds the data from the third allocation.");
}
```

## Environment 

```bash
$ uname -a
Linux ubuntu 3.16.0-77-generic #99~14.04.1-Ubuntu SMP Tue Jun 28 19:17:10 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux
```

## Execution

```
$ ./first_fit 
This file doesn't demonstrate an attack, but shows the nature of glibc's allocator.
glibc uses a first-fit algorithm to select a free chunk.
If a chunk is free and large enough, malloc will select this chunk.
This can be exploited in a use-after-free situation.
Allocating 2 buffers. They can be large, don't have to be fastbin.
1st malloc(512): 0x1a53010
2nd malloc(256): 0x1a53220
we could continue mallocing here...
now let's put a string at a that we can read later "this is A!"
first allocation 0x1a53010 points to this is A!
Freeing the first one...
We don't need to free anything again. As long as we allocate less than 512, it will end up at 0x1a53010
So, let's allocate 500 bytes
3rd malloc(500): 0x1a53010
And put a different string here, "this is C!"
3rd allocation 0x1a53010 points to this is C!
first allocation 0x1a53010 points to this is C!
If we reuse the first allocation, it now holds the data from the third allocation.
```

## Understand

heap allocator 의 first-fit 은 맞는 chunk 가 있으면 바로 할당해 주는 듯. **이전에 free 가 된 chuck 가 있어서 이보다 작은 size alloc 이 있는 경우에는 이를 바로 할당**하여 준다.

![heap first fit](https://raw.githubusercontent.com/humb1ec0ding/humb1ec0ding-etc/master/2016/09/heap_first_fit.jpg)





